	SOLID — аббревиатура, обозначающая пять принципов объектно-ориентированного проектирования. 
Эти принципы были сформулированы Робертом Мартином и призваны сделать код более поддерживаемым, 
гибким и понятным.

	S - SRP - принцип единственной ответственности. Этот принцип диктует, что каждый метод или
класс должен реализовывать лишь единственный функционал. То есть мы должны четко разделить сферы влияния
того или иного метода. Например перед нами стоит задача реализовать логирования какой-либо информации и
запись её в базу данных, следуя первому принципу SOLID мы должны выделить эту задачу под два класса, один
логирует, другой записывает в базу данных. Пример того, как первый принцип SOLID был реализован в задании
WordCount.
	В изначальной версии кода класс countFileStats выполняет слишком много задач. Открывает файлы,
считает байты, читает содержимое и так далее.
	Он был разбит на два класса FileReader, StatsCounter. Каждый из них выполняет только свой круг
задач.

	O - OCP - принцип открытости/закрытости. Гласит в первую очередь о том, что при методы и классы
должны иметь возможность модифицироваться, но не изменяться, а если возникает необходимость добавить новый
функционал, то следует создать новый класс. Такой подход уменьшает вероятность поломок в уже работающем коде,
но полностью следовать ему не получается из-за того, что код рано или поздно приходится менять.
	В изначальной версии операторы арифметических операций были жестко закодированы в структуре.
	В новой версии каждая операция реализована как отедльный класс-наследник

	L - LSP - пинцип Лисков. Гласит о том, что классы наследники должны реализовывать все те методы,
что были у их класса родителя, то есть если у нас есть класс программист, который может писать код,
то все его наследники должны тоже писать код. Не должно быть такого класса, который бы не реализовывал бы
этот метод.
	В изначальной версии в целом все было неплохо с точки зрения реализации класса, но в новой версии 
этот принцип отдельно был проконтролирован.

	I - ICP - принцип разделения интерфейсов. Гласит о том, что гараздо более правильно и выгодно раз-
делять интерфейсы на небольшие интерфейсы, чем делать один единый интерфейс. Дело в том, что в дальнейшей
реализации кода возможно настанет момент, когда появится экземпляр или класс, который несоответствует уже
существующему базовому интерфейсу.
	В изначальной версии кода часто встречался один единый интерфейс, может быть два, было это вызвано тем,
что изначальная задача была ясна, поэтому такое себе можно было позволить, но код был переделан.
	В измененной версии кода были добавлены новые интерфейсы. IMetadataBlock - базовый. ITextMetadata
- текстовый интерфейс. IWebLink - веб-ссылочный интерфейс. IUserComment - интерфейс для комментариев, и так
далее.
	
	D - DIP - модули верхнего уровня не должны зависеть от модулей нижнего уровня. 
Оба должны зависеть от абстракций.
	В старом коде есть несколько нарушений этого принципа: TicketToRide, UnlimitedTicket и 
LimitedTicketWithRides напрямую наследуются от Ticket. В main.py создаются конкретные экземпляры классов билетов.
	В новом коде был создана абстракция ITicket.py. Усовершенствованы main и Ticket.	